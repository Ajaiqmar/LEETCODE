// THE PROBLEM STATEMENT IS TO CHECK WHETHER THE TARGET ARRAY CAN BE MADE EQUAL TO ARR ARRAY BY REVERSING NON-EMPTY SUB ARRAYS PRESENT IN THE ARRAY ARR.

// MY APPROACH IS TO CHECK IF THE NUMBER OF OCCURRENCES OF INTEGERS IN BOTH THE ARRAY ARE EQUAL USING HASHTABLE. THE REASON IS SINCE WE WOULD BE ABLE REVERSE THE ANY NUMBER OF
// SUBARRAYS PRESENT IN THE ARRAY ARR. SO IF THE NUMBER OF OCCURRENCE OF ALL THE INTEGERS PRESENT IN BOTH ARRAY MATCH, IT IS JUST A MATTER OF REVERSING ANY NUMBER
// OF SUBARRAYS TO MATCH BOTH THE ARRAY.

bool canBeEqual(int* target, int targetSize, int* arr, int arrSize)
{
    int targetMap[1001] = {0};
    
    // TRAVERSING THE TARGET ARRAY AND STORING THE NUMBER OF OCCURRENCES IN THE HASH TABLE.
    for(int i=0;i<targetSize;i++)
    {
        targetMap[target[i]] += 1;
    }
    
    // TRAVERSING THE ARR ARRAY AND CHECKING THE NUMBER OF OCCURRENCES IN THE HASH TABLE MATCH.
    for(int i=0;i<arrSize;i++)
    {
        if(targetMap[arr[i]] == 0)
        {
            return false;
        }
        targetMap[arr[i]] -= 1;
    }
    
    return true;
}

// TIME COMPLEXITY : O(N)
// SPACE COMPLEXITY : O(N)

// THE PROBLEM STATEMENT IS TO FIND THE WINNER OF CIRCULAR GAME. THE RULES OF THE CIRCULAR GAME IS WE FIRST ARRANGE THE PEOPLE NUMBERED FROM 1 TO N
// IN A CIRCLE. THEN FROM THE PERSON WHOSE INDEX IS 1 WE START THE COUNT, IF THE COUNT REACHES K WE REMOVE THAT PERSON FROM THE GAME AND RESET THE VALUE
// OF COUNT BACK TO 0. SINCE THE PEOPLE ARE STANDING IN A CIRCULAR FORM, SO THE TURNS WILL GO AROUND IN A CLOCKWISE DIRECTION. WE HAVE TO RETUN WINNERS INDEX.

// APPROACH - I
// MY APPROACH IS TO FIRST CREATE A LINKED LIST OF LENGTH N WHERE EACH NODE WILL REPRESENT A PLAYER. THEN WE GO ONTO REMOVING THE PLAYERS ON EACH ITERATION
// WHOSE INDEX IS EQUAL TO THE VALUE IND. IF THE VALUE OF IND OVERFLOWS ABOVE THE LINKEDLIST SIZE, WE USE THE MODULO OPERATION TO BRING
// BACK VALUE OF IND LESS THAN THE LINKEDLIST SIZE. AT EACH ITERATION, WE INCREMENT THE VALUE OF IND BY K, TO PINPOINT THE PERSON WHON LOST IN THAT ROUND.
// THEN AFTER N-1 ITERATION, WE RETURN THE INDEX OF THE PERSON AT INDEX 0 OF THE LINKED LIST.

class Solution 
{
    public int findTheWinner(int n, int k) 
    {
        LinkedList<Integer> ll = new LinkedList<Integer>();
        // INITIALISING THE LINKEDLIST.
        for(int i=1;i<=n;i++)
        {
            ll.add(i);
        }
        
        int l = 0,ind = 0;
        // SIMULATION OF THE GAME.
        while(l<(n-1))
        {
            int s = ll.size();
            
            ind = (ind+(k-1))%s;
            
            if(ind == -1)
            {
                ind = s-1;
            }
            
            ll.remove(ind);
            
            s = ll.size();
            ind = ind%s;
            l += 1;
        }
        
        return ll.get(0);
    }
}

// TIME COMPLEXITY : O(N*N) SINCE WE HAVE TO REMOVE THE PERSON WHO LOST AT EACH ROUND, WHICH SIMPLY IMPLIES, WE HAVE TO TRAVERSE THE LINKED LIST AND REMOVE THE NODE.
// SPACE COMPLEXITY : O(N)


// APPROACH - II : 
// ANOTHER APPROACH THAT I OBTAINED FROM THE DISCUSSION BOARD, WAS THAT TO USE BOTTOM - UP DYNAMMIC PROGRAMMING, WHICH IS BASED ON THE EQUATION
// CALLED THE JOSEPHUS PROBLEM (WIKI : https://en.wikipedia.org/wiki/Josephus_problem). ACCORDING TO WHAT I GATHERED, THE PROBLEM IS BASED ON THE FACT THAT
// THE WINNER IN THE N-TH ROUND WOULD BE AT INDEX 0, THAT'S WHY THE INITIAL VALUE OF RES IS ZERO, NOW ON THE (N-1)-TH ROUND, THE WINNER WOULD BE AT EITHER 0 OR 1
// DEPENDING ON THE VALUE OF K, SO THAT'S WHY WE ARE ADDING K AND INORDER TO AVOID OVERFLOW WE USE THE MODULO OPERATION WHERE THE DENOMINATOR 
// I IS THE LENGTH OF THE LIST, IN THIS CASE THE LENGTH IS 2. SIMILARLY, FOR EACH ROUND WE ARE PREDICTING AT WHICH INDEX THE WINNER WOULD BE PRESENT
// INORDER TO WIN THAT ROUND. AT THE FINAL ROUND, WE OBTAIN THE RESULTANT INDEX, NOW SINCE WE USED ZERO-BASED INDEX AND THE GAME FOLLOWS ONE-BASED INDEX
// WE INCREMENT RES VALUE BY ONE.

class Solution 
{
    public int findTheWinner(int n, int k) 
    {
        int res = 0;
        
        // WORKING OUR WAY UP FROM THE FINAL ROUND.
        for(int i=1;i<=n;i++)
        {
            res = (res+k)%i;
        }
        
        return res+1;
    }
}

// TIME COMPLEXITY : O(N)
// SPACE COMPLEXITY : O(1)
